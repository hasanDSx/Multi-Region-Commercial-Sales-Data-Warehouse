USE Global_Retail_SupplyChain;

--------------------------------------------------------------------------------
-- 1. Yearly Growth Analysis
--------------------------------------------------------------------------------

-- Total Sales, Orders, and Transactions per Year with YoY Growth
WITH YearlySummary AS (
    SELECT
        CalendarYear AS ActualYear, 
        COUNT(DISTINCT SalesOrderNumber) AS TotalOrders,
        COUNT(*) AS TotalTransactions,
        SUM(SalesAmount) AS TotalSales,
        SUM(TotalProductCost) AS TotalCost,
        SUM(Profit) AS TotalProfit,
        COUNT(DISTINCT MonthNumberOfYear) AS MonthsCount
    FROM vw_SalesWithDate
    GROUP BY CalendarYear
)
SELECT
    ActualYear,
    FORMAT(TotalOrders, 'N0') AS TotalOrders,
    FORMAT(TotalTransactions, 'N0') AS TotalTransactions,
    CONCAT('$ ', FORMAT(TotalSales, 'N2')) AS TotalSales,
    CONCAT('$ ', FORMAT(TotalCost, 'N2')) AS TotalCost,
    CONCAT('$ ', FORMAT(TotalProfit, 'N2')) AS TotalProfit,
    FORMAT((TotalProfit * 100.0 / NULLIF(TotalSales, 0)), 'N2') + '%' AS ProfitMargin,
    CASE 
        WHEN MonthsCount < 12 THEN 'Partial Data (' + CAST(MonthsCount AS VARCHAR) + ' month(s))'
        WHEN LAG(MonthsCount) OVER (ORDER BY ActualYear) < 12 THEN 'Not Comparable'
        WHEN LAG(TotalOrders) OVER (ORDER BY ActualYear) IS NULL THEN 'N/A'
        ELSE CONCAT(FORMAT(((TotalOrders - LAG(TotalOrders) OVER (ORDER BY ActualYear)) * 100.0 / LAG(TotalOrders) OVER (ORDER BY ActualYear)), 'N2'), '%')
    END AS OrdersGrowth,
    CASE 
        WHEN MonthsCount < 12 THEN 'Partial Data'
        WHEN LAG(MonthsCount) OVER (ORDER BY ActualYear) < 12 THEN 'Not Comparable'
        WHEN LAG(TotalSales) OVER (ORDER BY ActualYear) IS NULL THEN 'N/A'
        ELSE CONCAT(FORMAT(((TotalSales - LAG(TotalSales) OVER (ORDER BY ActualYear)) * 100.0 / LAG(TotalSales) OVER (ORDER BY ActualYear)), 'N2'), '%')
    END AS SalesGrowth
FROM YearlySummary
ORDER BY ActualYear;

--------------------------------------------------------------------------------
-- 2. MONTHLY & QUARTERLY ANALYSIS
--------------------------------------------------------------------------------

-- Monthly Sales Breakdown with YTD
WITH MonthlySales AS (
    SELECT
        CalendarYear,
        MonthNumberOfYear,
        EnglishMonthName,
        COUNT(DISTINCT SalesOrderNumber) AS Orders,
        SUM(SalesAmount) AS Sales,
        SUM(Profit) AS Profit
    FROM vw_SalesWithDate
    GROUP BY CalendarYear, MonthNumberOfYear, EnglishMonthName
)
SELECT
    CalendarYear,
    MonthNumberOfYear,
    EnglishMonthName,
    FORMAT(Orders, 'N0') AS TotalOrders,
    CONCAT('$ ', FORMAT(Sales, 'N2')) AS MonthlySales,
    CONCAT('$ ', FORMAT(Profit, 'N2')) AS MonthlyProfit,
    CONCAT('$ ', FORMAT(SUM(Sales) OVER (PARTITION BY CalendarYear ORDER BY MonthNumberOfYear), 'N2')) AS YTDSales,
    FORMAT((Profit * 100.0 / NULLIF(Sales, 0)), 'N2') + '%' AS ProfitMargin
FROM MonthlySales
ORDER BY CalendarYear, MonthNumberOfYear;

-- Quarterly Performance with YoY Growth
WITH QuarterlySales AS (
    SELECT
        CalendarYear,
        CalendarQuarter,
        COUNT(DISTINCT SalesOrderNumber) AS TotalOrders,
        SUM(SalesAmount) AS QuarterlySales,
        SUM(Profit) AS QuarterlyProfit,
        COUNT(DISTINCT MonthNumberOfYear) AS MonthsCount
    FROM vw_SalesWithDate
    GROUP BY CalendarYear, CalendarQuarter
)
SELECT
    CalendarYear,
    CalendarQuarter,
    TotalOrders,
    CONCAT('$ ', FORMAT(QuarterlySales, 'N2')) AS QuarterlySales,
    CONCAT('$ ', FORMAT(QuarterlyProfit, 'N2')) AS QuarterlyProfit,
    FORMAT((QuarterlyProfit * 100.0 / NULLIF(QuarterlySales, 0)), 'N2') + '%' AS ProfitMargin,
    CASE 
        WHEN MonthsCount < 3 AND LAG(MonthsCount) OVER (PARTITION BY CalendarQuarter ORDER BY CalendarYear) < 3 THEN 'Both Partial'
        WHEN LAG(MonthsCount) OVER (PARTITION BY CalendarQuarter ORDER BY CalendarYear) < 3 THEN 'Not Comparable'
        WHEN LAG(QuarterlySales) OVER (PARTITION BY CalendarQuarter ORDER BY CalendarYear) IS NULL THEN 'N/A'
        ELSE CONCAT(
            FORMAT(((QuarterlySales - LAG(QuarterlySales) OVER (PARTITION BY CalendarQuarter ORDER BY CalendarYear)) * 100.0
                / NULLIF(LAG(QuarterlySales) OVER (PARTITION BY CalendarQuarter ORDER BY CalendarYear), 0)), 'N2'), '%',
            CASE WHEN MonthsCount < 3 THEN CONCAT(' (', MonthsCount, '/3 months)') ELSE '' END)
    END AS YoYGrowth
FROM QuarterlySales
ORDER BY CalendarYear, CalendarQuarter;

--------------------------------------------------------------------------------
-- 3. Inventory Analysis
--------------------------------------------------------------------------------

-- Inventory Movement with Stock Status
WITH InventoryData AS (
    SELECT 
        P.EnglishProductName,
        P.ProductKey,
        D.CalendarYear,
        D.MonthNumberOfYear,
        SUM(FI.UnitsBalance) AS Units,
        SUM(FI.UnitCost * FI.UnitsBalance) AS InventoryValue,
        AVG(FI.UnitCost) AS AvgUnitCost
    FROM FactProductInventory AS FI 
    JOIN DimProduct AS P ON FI.ProductKey = P.ProductKey 
    JOIN DimDate AS D ON FI.DateKey = D.DateKey
    GROUP BY P.EnglishProductName, P.ProductKey, D.CalendarYear, D.MonthNumberOfYear
)
SELECT 
    EnglishProductName,
    CalendarYear,
    MonthNumberOfYear,
    FORMAT(Units, 'N0') AS CurrentUnits,
    CONCAT('$ ', FORMAT(InventoryValue, 'N2')) AS InventoryValue,
    CONCAT('$ ', FORMAT(AvgUnitCost, 'N2')) AS AvgUnitCost,
    CASE 
        WHEN Units < 100 THEN 'Low Stock'
        WHEN Units < 500 THEN 'Normal'
        ELSE 'Overstocked'
    END AS StockStatus
FROM InventoryData
ORDER BY CalendarYear, MonthNumberOfYear, EnglishProductName;

--------------------------------------------------------------------------------
-- 4. Customer Analysis (Combined CLV, RFM, Churn)
--------------------------------------------------------------------------------

-- Comprehensive Customer Analysis
WITH CustomerMetrics AS (
    SELECT 
        S.CustomerKey,
        C.CustomerName,
        C.EmailAddress,
        C.Country,
        MIN(S.FullDateAlternateKey) AS FirstPurchaseDate,
        MAX(S.FullDateAlternateKey) AS LastPurchaseDate,
        DATEDIFF(DAY, MAX(S.FullDateAlternateKey), GETDATE()) AS Recency,
        COUNT(DISTINCT S.SalesOrderNumber) AS Frequency,
        SUM(S.SalesAmount) AS Monetary,
        SUM(S.Profit) AS TotalProfit,
        AVG(S.SalesAmount) AS AvgOrderValue,
        DATEDIFF(DAY, MIN(S.FullDateAlternateKey), MAX(S.FullDateAlternateKey)) AS CustomerLifespanDays
    FROM vw_SalesWithDate AS S
    JOIN vw_CustomerGeography AS C ON S.CustomerKey = C.CustomerKey
    GROUP BY S.CustomerKey, C.CustomerName, C.EmailAddress, C.Country
),
RFMScores AS (
    SELECT 
        *,
        NTILE(5) OVER (ORDER BY Recency DESC) AS R_Score,
        NTILE(5) OVER (ORDER BY Frequency) AS F_Score,
        NTILE(5) OVER (ORDER BY Monetary) AS M_Score
    FROM CustomerMetrics
)
SELECT 
    CustomerKey,
    CustomerName,
    EmailAddress,
    Country,
    FirstPurchaseDate,
    LastPurchaseDate,
    Recency AS DaysSinceLastPurchase,
    Frequency AS TotalOrders,
    CONCAT('$ ', FORMAT(Monetary, 'N2')) AS TotalRevenue,
    CONCAT('$ ', FORMAT(TotalProfit, 'N2')) AS TotalProfit,
    CONCAT('$ ', FORMAT(AvgOrderValue, 'N2')) AS AvgOrderValue,
    CASE 
        WHEN CustomerLifespanDays > 0 
        THEN CONCAT('$ ', FORMAT((Monetary * 365.0 / CustomerLifespanDays), 'N2'))
        ELSE 'N/A'
    END AS AnnualizedCLV,
    CONCAT(R_Score, F_Score, M_Score) AS RFM_Score,
    CASE 
        WHEN R_Score >= 4 AND F_Score >= 4 AND M_Score >= 4 THEN 'Champions'
        WHEN R_Score >= 3 AND F_Score >= 3 AND M_Score >= 3 THEN 'Loyal Customers'
        WHEN R_Score >= 4 AND F_Score <= 2 THEN 'Promising'
        WHEN R_Score <= 2 AND F_Score >= 3 THEN 'At Risk'
        WHEN R_Score <= 2 AND F_Score <= 2 THEN 'Lost'
        ELSE 'Potential'
    END AS CustomerSegment,
    CASE 
        WHEN Recency <= 90 THEN 'Active'
        WHEN Recency <= 180 THEN 'At Risk'
        WHEN Recency <= 365 THEN 'Dormant'
        ELSE 'Lost'
    END AS ChurnStatus,
    CASE 
        WHEN Monetary > 10000 THEN 'Platinum'
        WHEN Monetary > 5000 THEN 'Gold'
        WHEN Monetary > 2000 THEN 'Silver'
        ELSE 'Bronze'
    END AS CustomerTier
FROM RFMScores
ORDER BY Monetary DESC;

--------------------------------------------------------------------------------
-- 5. PRODUCT ANALYSIS
--------------------------------------------------------------------------------

-- Product Performance with ABC Analysis
WITH ProductMetrics AS (
    SELECT 
        P.EnglishProductName,
        P.Category,
        P.Subcategory,
        COUNT(DISTINCT S.SalesOrderNumber) AS OrderCount,
        SUM(S.OrderQuantity) AS UnitsSold,
        SUM(S.SalesAmount) AS TotalRevenue,
        SUM(S.Profit) AS TotalProfit,
        AVG(S.UnitPrice) AS AvgPrice,
        AVG(S.UnitPriceDiscountPct) AS AvgDiscountPct
    FROM vw_SalesWithDate AS S
    JOIN vw_ProductHierarchy AS P ON S.ProductKey = P.ProductKey
    GROUP BY P.EnglishProductName, P.Category, P.Subcategory
),
RankedProducts AS (
    SELECT 
        *,
        ROW_NUMBER() OVER (ORDER BY TotalRevenue DESC) AS Rank,
        SUM(TotalRevenue) OVER (ORDER BY TotalRevenue DESC) AS CumulativeRevenue,
        SUM(TotalRevenue) OVER () AS GrandTotalRevenue
    FROM ProductMetrics
)
SELECT 
    Rank,
    EnglishProductName,
    Category,
    Subcategory,
    FORMAT(OrderCount, 'N0') AS TotalOrders,
    FORMAT(UnitsSold, 'N0') AS UnitsSold,
    CONCAT('$ ', FORMAT(TotalRevenue, 'N2')) AS Revenue,
    CONCAT('$ ', FORMAT(TotalProfit, 'N2')) AS Profit,
    FORMAT((TotalProfit * 100.0 / NULLIF(TotalRevenue, 0)), 'N2') + '%' AS ProfitMargin,
    CONCAT('$ ', FORMAT(AvgPrice, 'N2')) AS AvgPrice,
    FORMAT(AvgDiscountPct * 100, 'N2') + '%' AS AvgDiscount,
    FORMAT((CumulativeRevenue * 100.0 / GrandTotalRevenue), 'N2') + '%' AS CumulativeShare,
    CASE 
        WHEN (CumulativeRevenue * 100.0 / GrandTotalRevenue) <= 80 THEN 'A - Top 80%'
        WHEN (CumulativeRevenue * 100.0 / GrandTotalRevenue) <= 95 THEN 'B - Next 15%'
        ELSE 'C - Bottom 5%'
    END AS ABCCategory,
    CASE 
        WHEN TotalProfit / NULLIF(TotalRevenue, 0) > 0.4 THEN 'High Margin'
        WHEN TotalProfit / NULLIF(TotalRevenue, 0) > 0.2 THEN 'Medium Margin'
        ELSE 'Low Margin'
    END AS MarginCategory
FROM RankedProducts
ORDER BY Rank;

-- Product Category Trends
WITH CategorySales AS (
    SELECT 
        P.Category,
        S.CalendarYear,
        S.CalendarQuarter,
        COUNT(DISTINCT S.SalesOrderNumber) AS Orders,
        SUM(S.OrderQuantity) AS UnitsSold,
        SUM(S.SalesAmount) AS Revenue,
        COUNT(DISTINCT S.MonthNumberOfYear) AS MonthsCount
    FROM vw_SalesWithDate AS S
    JOIN vw_ProductHierarchy AS P ON S.ProductKey = P.ProductKey
    GROUP BY P.Category, S.CalendarYear, S.CalendarQuarter
)
SELECT 
    Category,
    CalendarYear,
    CalendarQuarter,
    Orders,
    UnitsSold,
    CONCAT('$ ', FORMAT(Revenue, 'N2')) AS Revenue,
    CASE 
        WHEN LAG(MonthsCount) OVER (PARTITION BY Category, CalendarQuarter ORDER BY CalendarYear) < 3 THEN 'Not Comparable'
        WHEN LAG(Revenue) OVER (PARTITION BY Category, CalendarQuarter ORDER BY CalendarYear) IS NULL THEN 'N/A'
        ELSE CONCAT(
             FORMAT((Revenue - LAG(Revenue) OVER (PARTITION BY Category, CalendarQuarter ORDER BY CalendarYear)) * 100.0
             / NULLIF(LAG(Revenue) OVER (PARTITION BY Category, CalendarQuarter ORDER BY CalendarYear), 0), 'N2'), '%',
            CASE WHEN MonthsCount < 3 THEN ' (Partial)' ELSE '' END)
    END AS YoYGrowth
FROM CategorySales
ORDER BY Category, CalendarYear, CalendarQuarter;

--------------------------------------------------------------------------------
-- 6. SALES TERRITORY ANALYSIS
--------------------------------------------------------------------------------

-- Territory Performance Dashboard with Market Share
WITH TerritoryMetrics AS (
    SELECT 
        T.SalesTerritoryRegion,
        T.SalesTerritoryCountry,
        T.SalesTerritoryGroup,
        S.CalendarYear,
        COUNT(DISTINCT S.SalesOrderNumber) AS TotalOrders,
        COUNT(DISTINCT S.CustomerKey) AS UniqueCustomers,
        SUM(S.SalesAmount) AS TotalRevenue,
        SUM(S.Profit) AS TotalProfit,
        SUM(SUM(S.SalesAmount)) OVER (PARTITION BY S.CalendarYear) AS YearTotalRevenue,
        COUNT(DISTINCT S.MonthNumberOfYear) AS MonthsCount
    FROM vw_SalesWithDate AS S
    JOIN vw_TerritoryInfo AS T ON S.SalesTerritoryKey = T.SalesTerritoryKey
    GROUP BY T.SalesTerritoryRegion, T.SalesTerritoryCountry, T.SalesTerritoryGroup, S.CalendarYear
)
SELECT 
    SalesTerritoryRegion,
    SalesTerritoryCountry,
    SalesTerritoryGroup,
    CalendarYear,
    FORMAT(TotalOrders, 'N0') AS Orders,
    FORMAT(UniqueCustomers, 'N0') AS Customers,
    CONCAT('$ ', FORMAT(TotalRevenue, 'N2')) AS Revenue,
    CONCAT('$ ', FORMAT(TotalProfit, 'N2')) AS Profit,
    FORMAT((TotalProfit * 100.0 / NULLIF(TotalRevenue, 0)), 'N2') + '%' AS ProfitMargin,
    FORMAT((TotalRevenue * 100.0 / YearTotalRevenue), 'N2') + '%' AS MarketShare,
    CONCAT('$ ', FORMAT((TotalRevenue * 1.0 / NULLIF(UniqueCustomers, 0)), 'N2')) AS RevenuePerCustomer,
    CASE 
        WHEN LAG(MonthsCount) OVER (PARTITION BY SalesTerritoryRegion ORDER BY CalendarYear) < 12 THEN 'Not Comparable'
        WHEN LAG(TotalRevenue) OVER (PARTITION BY SalesTerritoryRegion ORDER BY CalendarYear) IS NULL THEN 'N/A'
        ELSE CONCAT(
            FORMAT(((TotalRevenue - LAG(TotalRevenue) OVER (PARTITION BY SalesTerritoryRegion ORDER BY CalendarYear))* 100.0
            / NULLIF(LAG(TotalRevenue) OVER (PARTITION BY SalesTerritoryRegion ORDER BY CalendarYear), 0)), 'N2'),'%',
            CASE WHEN MonthsCount < 12 THEN ' (Partial)'ELSE '' END)
    END AS YoYGrowth
FROM TerritoryMetrics
ORDER BY SalesTerritoryGroup, CalendarYear, TotalRevenue DESC;

--------------------------------------------------------------------------------
-- 7. PROMOTION ANALYSIS
--------------------------------------------------------------------------------

-- Promotion Effectiveness with Comparison
WITH PromotionMetrics AS (
    SELECT 
        PR.EnglishPromotionName,
        PR.EnglishPromotionType,
        PR.EnglishPromotionCategory,
        PR.DiscountPct,
        CASE WHEN PR.PromotionKey > 1 THEN 'With Promotion' ELSE 'No Promotion' END AS PromotionStatus,
        COUNT(DISTINCT S.SalesOrderNumber) AS OrdersWithPromo,
        SUM(S.SalesAmount) AS RevenueWithPromo,
        SUM(S.Profit) AS ProfitWithPromo,
        AVG(S.OrderQuantity) AS AvgQuantityPerOrder
    FROM vw_SalesWithDate AS S
    JOIN DimPromotion AS PR ON S.PromotionKey = PR.PromotionKey
    GROUP BY PR.EnglishPromotionName, PR.EnglishPromotionType, PR.EnglishPromotionCategory, PR.DiscountPct, 
        CASE WHEN PR.PromotionKey > 1 THEN 'With Promotion' ELSE 'No Promotion' END
)
SELECT 
    PromotionStatus,
    EnglishPromotionName,
    EnglishPromotionType,
    EnglishPromotionCategory,
    FORMAT(DiscountPct * 100, 'N2') + '%' AS DiscountRate,
    FORMAT(OrdersWithPromo, 'N0') AS TotalOrders,
    CONCAT('$ ', FORMAT(RevenueWithPromo, 'N2')) AS Revenue,
    CONCAT('$ ', FORMAT(ProfitWithPromo, 'N2')) AS Profit,
    FORMAT((ProfitWithPromo * 100.0 / NULLIF(RevenueWithPromo, 0)), 'N2') + '%' AS ProfitMargin,
    CONCAT('$ ', FORMAT((RevenueWithPromo / NULLIF(OrdersWithPromo, 0)), 'N2')) AS RevenuePerOrder,
    FORMAT(AvgQuantityPerOrder, 'N2') AS AvgItemsPerOrder
FROM PromotionMetrics
ORDER BY PromotionStatus DESC, ProfitWithPromo DESC;

--------------------------------------------------------------------------------
-- 8. TIME ANALYSIS (Day of Week & Seasonal)
--------------------------------------------------------------------------------

-- Sales by Day of Week
SELECT 
    DayNumberOfWeek,
    EnglishDayNameOfWeek,
    COUNT(DISTINCT SalesOrderNumber) AS TotalOrders,
    CONCAT('$ ', FORMAT(SUM(SalesAmount), 'N2')) AS TotalRevenue,
    CONCAT('$ ', FORMAT(AVG(SalesAmount), 'N2')) AS AvgOrderValue,
    FORMAT((SUM(SalesAmount) * 100.0 / SUM(SUM(SalesAmount)) OVER ()), 'N2') + '%' AS PercentOfTotal,
    FORMAT(((SUM(SalesAmount) - AVG(SUM(SalesAmount)) OVER ()) * 100.0 / AVG(SUM(SalesAmount)) OVER ()), 'N2') + '%' AS VsWeeklyAvg
FROM vw_SalesWithDate
GROUP BY DayNumberOfWeek, EnglishDayNameOfWeek
ORDER BY DayNumberOfWeek;

-- Seasonal Analysis
WITH SeasonalSales AS ( 
    SELECT  
        CalendarYear, 
        Season, 
        COUNT(DISTINCT SalesOrderNumber) AS Orders, 
        SUM(SalesAmount) AS Revenue, 
        SUM(Profit) AS Profit,
        COUNT(DISTINCT MonthNumberOfYear) AS MonthsCount
    FROM vw_SalesWithDate
    GROUP BY CalendarYear, Season
) 
SELECT  
    CalendarYear, 
    Season, 
    FORMAT(Orders, 'N0') AS TotalOrders, 
    CONCAT('$ ', FORMAT(Revenue, 'N2')) AS SeasonalRevenue, 
    CONCAT('$ ', FORMAT(Profit, 'N2')) AS SeasonalProfit, 
    FORMAT((Profit * 100.0 / NULLIF(Revenue, 0)), 'N2') + '%' AS ProfitMargin, 
    CASE 
        WHEN MonthsCount < 3 
        THEN FORMAT((Revenue * 100.0 / SUM(Revenue) OVER (PARTITION BY CalendarYear)), 'N2') + '% *'
        ELSE FORMAT((Revenue * 100.0 / SUM(Revenue) OVER (PARTITION BY CalendarYear)), 'N2') + '%'
    END AS PercentOfYear,
    CASE 
        WHEN LAG(MonthsCount) OVER (PARTITION BY Season ORDER BY CalendarYear) < 3 THEN 'Not Comparable'
        WHEN LAG(Revenue) OVER (PARTITION BY Season ORDER BY CalendarYear) IS NULL THEN 'N/A'
        ELSE CONCAT(
            FORMAT(
                ((Revenue - LAG(Revenue) OVER (PARTITION BY Season ORDER BY CalendarYear))
                * 100.0 / NULLIF(LAG(Revenue) OVER (PARTITION BY Season ORDER BY CalendarYear), 0)), 'N2'),'%',
            CASE  WHEN MonthsCount < 3 THEN ' (Partial)' ELSE ''  END)
    END AS YoYGrowth
FROM SeasonalSales 
ORDER BY CalendarYear,  
    CASE Season  
        WHEN 'Winter' THEN 1  
        WHEN 'Spring' THEN 2  
        WHEN 'Summer' THEN 3  
        WHEN 'Fall' THEN 4  
    END;

--------------------------------------------------------------------------------
-- 9. SHIPPING & DELIVERY ANALYSIS
--------------------------------------------------------------------------------

-- Shipping Performance & Freight Cost Analysis
SELECT 
    T.SalesTerritoryRegion,
    S.CalendarYear,
    S.CalendarQuarter,
    COUNT(DISTINCT S.SalesOrderNumber) AS TotalOrders,
    CONCAT('$ ', FORMAT(SUM(S.Freight), 'N2')) AS TotalFreightCost,
    CONCAT('$ ', FORMAT(AVG(S.Freight), 'N2')) AS AvgFreightPerOrder,
    CONCAT('$ ', FORMAT(SUM(S.SalesAmount), 'N2')) AS TotalRevenue
FROM vw_SalesWithDate AS S
JOIN vw_TerritoryInfo AS T ON S.SalesTerritoryKey = T.SalesTerritoryKey
GROUP BY T.SalesTerritoryRegion, S.CalendarYear, S.CalendarQuarter
ORDER BY S.CalendarYear, S.CalendarQuarter, TotalRevenue DESC;

--------------------------------------------------------------------------------
-- 10. CURRENCY & EXCHANGE RATE ANALYSIS
--------------------------------------------------------------------------------

-- Sales by Currency with Exchange Impact
SELECT 
    CUR.CurrencyName,
    S.CalendarYear,
    COUNT(DISTINCT S.SalesOrderNumber) AS TotalOrders,
    CONCAT('$ ', FORMAT(ROUND(SUM(S.SalesAmount), 2), 'N2')) AS RevenueInLocalCurrency,
    ROUND(AVG(CR.EndOfDayRate), 4) AS AvgExchangeRate,
    CONCAT('$ ', FORMAT(ROUND(SUM(S.SalesAmount * CR.EndOfDayRate), 2), 'N2')) AS RevenueInUSD,
    CAST((SUM(S.SalesAmount * CR.EndOfDayRate) - SUM(S.SalesAmount))/SUM(S.SalesAmount)*100 AS DECIMAL(5,2)) AS ExchangeImpactPct,
    ROUND(MAX(CR.EndOfDayRate), 4) AS MaxExchangeRate
    ,
ROUND(MIN(CR.EndOfDayRate), 4) AS MinExchangeRate,
ROUND(STDEV(CR.EndOfDayRate), 4) AS ExchangeRateVolatility
FROM vw_SalesWithDate AS S
JOIN DimCurrency AS CUR ON S.CurrencyKey = CUR.CurrencyKey
JOIN FactCurrencyRate AS CR ON S.CurrencyKey = CR.CurrencyKey AND S.OrderDateKey = CR.DateKey
GROUP BY CUR.CurrencyName, S.CalendarYear
ORDER BY SUM(S.SalesAmount * CR.EndOfDayRate) DESC;

--------------------------------------------------------------------------------
-- 11. CUSTOMER DEMOGRAPHICS ANALYSIS
--------------------------------------------------------------------------------

-- Sales by Customer Demographics & Age Analysis
SELECT
    C.CustomerKey,
    C.Gender,
    C.MaritalStatus,
    C.IncomeRange,
    C.AgeGroup,
    C.EnglishEducation,
    C.EnglishOccupation,
    COUNT(DISTINCT C.CustomerKey) AS TotalCustomers,
    COUNT(DISTINCT S.SalesOrderNumber) AS TotalOrders,
    CONCAT('$ ', FORMAT(SUM(S.SalesAmount), 'N2')) AS TotalRevenue,
    CONCAT('$ ', FORMAT(AVG(S.SalesAmount), 'N2')) AS AvgOrderValue,
    CONCAT('$ ', FORMAT((SUM(S.SalesAmount) / COUNT(DISTINCT C.CustomerKey)), 'N2')) AS RevenuePerCustomer,
    FORMAT((COUNT(DISTINCT S.SalesOrderNumber) * 1.0 / COUNT(DISTINCT C.CustomerKey)), 'N2') AS OrdersPerCustomer
FROM vw_CustomerGeography AS C
JOIN vw_SalesWithDate AS S ON C.CustomerKey = S.CustomerKey
GROUP BY C.CustomerKey, C.Gender, C.MaritalStatus, C.IncomeRange, C.AgeGroup, C.EnglishEducation, C.EnglishOccupation
ORDER BY SUM(S.SalesAmount) DESC;

--------------------------------------------------------------------------------
-- 12. GEOGRAPHY ANALYSIS
--------------------------------------------------------------------------------

-- Sales by Country, Region, and Top Cities
WITH GeographySales AS (
    SELECT
        C.Country,
        C.State,
        C.City,
        COUNT(DISTINCT C.CustomerKey) AS TotalCustomers,
        COUNT(DISTINCT S.SalesOrderNumber) AS TotalOrders,
        SUM(S.SalesAmount) AS TotalRevenue,
        SUM(S.Profit) AS TotalProfit
    FROM vw_SalesWithDate AS S
    JOIN vw_CustomerGeography AS C ON S.CustomerKey = C.CustomerKey
    GROUP BY C.Country, C.State, C.City
),
CityRankings AS (
    SELECT
        *,
        RANK() OVER (PARTITION BY Country ORDER BY TotalRevenue DESC) AS CityRank
    FROM GeographySales
)
SELECT
    Country,
    CityRank,
    City,
    State,
    FORMAT(TotalCustomers, 'N0') AS TotalCustomers,
    FORMAT(TotalOrders, 'N0') AS TotalOrders,
    CONCAT('$ ', FORMAT(TotalRevenue, 'N2')) AS TotalRevenue,
    CONCAT('$ ', FORMAT(TotalProfit, 'N2')) AS TotalProfit,
    FORMAT((TotalProfit * 100.0 / NULLIF(TotalRevenue, 0)), 'N2') + '%' AS ProfitMargin,
    CONCAT('$ ', FORMAT((TotalRevenue / TotalCustomers), 'N2')) AS RevenuePerCustomer
FROM CityRankings
WHERE CityRank <= 10
ORDER BY Country, CityRank;

--------------------------------------------------------------------------------
-- 13. PRODUCT BUNDLE ANALYSIS (Market Basket)
--------------------------------------------------------------------------------

-- Products Frequently Bought Together
WITH ProductPairs AS (
    SELECT
        F1.ProductKey AS Product1,
        F2.ProductKey AS Product2,
        COUNT(DISTINCT F1.SalesOrderNumber) AS TimesBoughtTogether
    FROM FactInternetSales AS F1
    JOIN FactInternetSales AS F2 ON F1.SalesOrderNumber = F2.SalesOrderNumber AND F1.ProductKey < F2.ProductKey
    GROUP BY F1.ProductKey, F2.ProductKey
)
SELECT TOP 50
    P1.EnglishProductName AS Product1Name,
    P2.EnglishProductName AS Product2Name,
    PP.TimesBoughtTogether,
    FORMAT((PP.TimesBoughtTogether * 100.0
    /(SELECT COUNT(DISTINCT SalesOrderNumber) FROM FactInternetSales)), 'N2') + '%' AS SupportPercentage
FROM ProductPairs AS PP
JOIN vw_ProductHierarchy AS P1 ON PP.Product1 = P1.ProductKey
JOIN vw_ProductHierarchy AS P2 ON PP.Product2 = P2.ProductKey
ORDER BY PP.TimesBoughtTogether DESC;

--------------------------------------------------------------------------------
-- 14. PREDICTIVE METRICS & KPIs
--------------------------------------------------------------------------------

-- Customer Lifetime Value Prediction & Sales Velocity
WITH CustomerOrders AS (
    SELECT
        C.CustomerKey,
        C.CustomerName,
        S.FullDateAlternateKey,
        S.SalesOrderNumber,
        S.SalesAmount,
        LAG(S.FullDateAlternateKey) OVER (PARTITION BY C.CustomerKey ORDER BY S.FullDateAlternateKey) AS PrevOrderDate
FROM vw_SalesWithDate AS S
JOIN vw_CustomerGeography AS C ON S.CustomerKey = C.CustomerKey
),
CustomerMetrics AS (
    SELECT
        CustomerKey,
        CustomerName,
        DATEDIFF(DAY, MIN(FullDateAlternateKey), MAX(FullDateAlternateKey)) AS CustomerLifespanDays,
        COUNT(DISTINCT SalesOrderNumber) AS TotalOrders,
        SUM(SalesAmount) AS TotalRevenue,
        AVG(DATEDIFF(DAY, PrevOrderDate, FullDateAlternateKey)) AS AvgDaysBetweenOrders
    FROM CustomerOrders
    GROUP BY CustomerKey, CustomerName
)
SELECT
    CustomerName,
    TotalOrders,
    CONCAT('$ ', FORMAT(TotalRevenue, 'N2')) AS HistoricalRevenue,
    ISNULL(AvgDaysBetweenOrders, 0) AS AvgDaysBetweenPurchases,
    CASE
        WHEN AvgDaysBetweenOrders > 0 AND CustomerLifespanDays > 0
        THEN CONCAT('$ ', FORMAT((TotalRevenue * 365.0 / CustomerLifespanDays) * 3, 'N2'))
        ELSE 'N/A'
    END AS Projected3YearCLV,
    CASE
        WHEN AvgDaysBetweenOrders <= 30 THEN 'High Frequency'
        WHEN AvgDaysBetweenOrders <= 90 THEN 'Medium Frequency'
        ELSE 'Low Frequency'
    END AS PurchaseFrequency
FROM CustomerMetrics
WHERE TotalOrders > 1
ORDER BY TotalRevenue DESC;

-- Sales Velocity (Trend Analysis)
WITH MonthlySales AS (
    SELECT
        CalendarYear,
        MonthNumberOfYear,
        SUM(SalesAmount) AS MonthlyRevenue,
        ROW_NUMBER() OVER (ORDER BY CalendarYear, MonthNumberOfYear) AS MonthIndex,
        COUNT(SalesAmount) AS SalesCount
FROM vw_SalesWithDate
GROUP BY CalendarYear, MonthNumberOfYear
)
SELECT
    CalendarYear,
    MonthNumberOfYear,
    CONCAT('$ ', FORMAT(MonthlyRevenue, 'N2')) AS MonthlyRevenue,
    CONCAT('$ ', FORMAT(AVG(MonthlyRevenue) OVER (ORDER BY MonthIndex ROWS BETWEEN 2 PRECEDING AND CURRENT ROW), 'N2')) AS ThreeMonthMovingAvg,
    CASE
        WHEN LAG(MonthlyRevenue, 3) OVER (ORDER BY MonthIndex) IS NULL THEN 'N/A'
        WHEN LAG(SalesCount, 3) OVER (ORDER BY MonthIndex) < 15 THEN 'Not Comparable'
        ELSE CONCAT(FORMAT((MonthlyRevenue - LAG(MonthlyRevenue, 3) OVER (ORDER BY MonthIndex)) * 100.0
            / NULLIF(LAG(MonthlyRevenue, 3) OVER (ORDER BY MonthIndex), 0), 'N2'), '%')
    END AS QuarterOverQuarterGrowth
FROM MonthlySales
ORDER BY CalendarYear, MonthNumberOfYear;

--------------------------------------------------------------------------------
-- 15. PROFITABILITY DEEP DIVE
--------------------------------------------------------------------------------

-- Profit Margin Analysis by Multiple Dimensions
SELECT
    P.Category,
    T.SalesTerritoryRegion AS Territory,
    S.CalendarYear,
    COUNT(DISTINCT S.SalesOrderNumber) AS Orders,
    CONCAT('$ ', FORMAT(SUM(S.SalesAmount), 'N2')) AS Revenue,
    CONCAT('$ ', FORMAT(SUM(S.TotalProductCost), 'N2')) AS Cost,
    CONCAT('$ ', FORMAT(SUM(S.Profit), 'N2')) AS Profit,
    FORMAT((SUM(S.Profit) * 100.0 / NULLIF(SUM(S.SalesAmount), 0)), 'N2') + '%' AS ProfitMargin,
    RANK() OVER (PARTITION BY S.CalendarYear ORDER BY SUM(S.Profit) DESC) AS ProfitRank
FROM vw_SalesWithDate AS S
JOIN vw_ProductHierarchy AS P ON S.ProductKey = P.ProductKey
JOIN vw_TerritoryInfo AS T ON S.SalesTerritoryKey = T.SalesTerritoryKey
GROUP BY P.Category, T.SalesTerritoryRegion, S.CalendarYear
ORDER BY S.CalendarYear DESC, SUM(S.Profit) DESC;
